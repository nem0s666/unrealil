<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Редактор карт для Telegram</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* Стили для кастомных модальных окон */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 3000;
    }
    
    .modal-content {
        background-color: var(--bg-sidebar);
        padding: 20px;
        border-radius: 8px;
        max-width: 80%;
        min-width: 300px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .modal-title {
        margin-top: 0;
        margin-bottom: 15px;
        color: var(--text-main);
    }
    
    .modal-message {
        margin-bottom: 20px;
        color: var(--text-main);
    }
    
    .modal-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
    }
    
    .modal-button {
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        border: none;
    }
    
    .modal-button-confirm {
        background-color: #d9534f;
        color: white;
    }
    
    .modal-button-cancel {
        background-color: var(--button-bg);
        color: var(--text-main);
        border: 1px solid var(--border-color);
    } 
    .modal-button:hover {
    opacity: 0.9;
    transform: translateY(-1px);
    }
        #telegram-username {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.2);
            color: var(--text-main);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
        /* Добавим стили для модального окна выбора стиля */
        #styleModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .style-selector {
            background-color: var(--bg-sidebar);
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            text-align: center;
        }
        
        .style-option {
            margin: 15px 0;
            padding: 10px;
            border: 2px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .style-option:hover {
            background-color: var(--selection-color);
            border-color: var(--selection-color);
        }
        
        .style-option.selected {
            background-color: var(--selection-color);
            border-color: var(--selection-color);
        }
        
        .style-title {
            font-size: 18px;
            margin-bottom: 20px;
            color: var(--text-main);
        }
    :root {
        /* Светлая тема по умолчанию */
        --bg-main: #f0f0f0;
        --bg-canvas: #ffffff;
        --bg-sidebar: #ffffff;
        --bg-controls: rgba(255, 255, 255, 0.8);
        --text-main: #333333;
        --texture-bg: #f8f8f8;
        --texture-border: #aaaaaa;
        --texture-text: #333333;
        --text-light: #ffffff;
        --grid-color: rgba(150, 150, 150, 0.8);
        --border-color: #cccccc;
        --button-bg: #f0f0f0;
        --button-hover: #e0e0e0;
        --selection-color: #d0d0ff;
        --resize-handle: #ffffff;
    }

    /* Тёмная тема */
    .dark-theme {
        --bg-main: #1e1e1e;
        --bg-canvas: #2d2d2d;
        --bg-sidebar: #252526;
        --bg-controls: rgba(45, 45, 45, 0.8);
        --text-main: #e0e0e0;
        --texture-bg: #3a3a3a;
        --texture-border: #555555;
        --texture-text: #e0e0e0;
        --text-light: #ffffff;
        --grid-color: rgba(255, 255, 255, 0.15);
        --border-color: #444444;
        --button-bg: #3a3a3a;
        --button-hover: #4a4a4a;
        --selection-color: #4a6da7;
        --resize-handle: #4a6da7;
        --text-dark: #e0e0e0; /* Основной текст в темной теме */
        --text-light: #ffffff; /* Светлый текст */
        --object-bg: #3a3a3a; /* Фон элементов объектов */
        --object-border: #444444; /* Граница элементов объектов */
        --group-bg: #2a2a2a; /* Фон групп */
         --group-border: #4a6da7; /* Граница групп */
       }

    body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
        display: flex;
        height: 100vh;
        overflow: hidden;
        flex-direction: row-reverse;
        background-color: var(--bg-main);
        color: var(--text-main);
        transition: background-color 0.3s ease;
    }

    #zoomLevel {
        margin: 0 10px;
        min-width: 40px;
        display: inline-block;
        text-align: center;
        font-family: monospace;
        transition: transform 0.2s ease;
        color: var(--text-main);
    }

    @keyframes fadeIn {
    from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
    to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

    #sidebar {
    width: 360px;
    min-width: 260px;
    max-width: 600px;
    flex-shrink: 0;
    background: var(--bg-sidebar);
    padding: 10px;
    overflow-y: auto;
    box-sizing: border-box;
    transition: background-color 0.3s ease, border-color 0.3s ease;
    position: relative;
    border-right: 1px solid var(--border-color); /* Добавьте правую границу */
    border-left: none; /* Уберите левую границу */
    resize: none; /* Отключите стандартный resize */
}

     .sidebar-content {
        overflow-y: auto;
        height: calc(100% - 40px); /* Высота минус высота тулбара */
        padding: 10px;
        box-sizing: border-box;
    }

    .sidebar-resize-handle {
    position: absolute;
    left: -5px;
    top: 0;
    bottom: 0;
    width: 10px;
    cursor: col-resize;
    z-index: 10;
}

    #editorCanvas {
        background: var(--bg-canvas);
        cursor: default;
        flex-grow: 1;
        transition: background-color 0.3s ease;
        image-rendering: crisp-edges;
        image-rendering: pixelated;
    }

    #controls {
        position: fixed;
        bottom: 10px;
        left: 560px;
        right: auto;
        background: var(--bg-controls);
        padding: 5px;
        border-radius: 5px;
        display: flex;
        gap: 5px;
        transition: background-color 0.3s ease;
    }

    button {
        padding: 5px 10px;
        cursor: pointer;
        background-color: var(--button-bg);
        color: var(--text-main);
        border: 1px solid var(--border-color);
        border-radius: 3px;
        transition: all 0.2s ease;
    }

    button:hover {
        background-color: var(--button-hover);
    }

    .object-entry {
        cursor: pointer;
        padding: 4px;
        margin: 2px 0;
        border-radius: 3px;
        color: var(--text-main);
        background-color: var(--button-bg);
        border: 1px solid var(--border-color);
        transition: background-color 0.2s ease;
    }

    .group-toolbar {
        display: flex;
        gap: 3px;
        margin-left: auto;
        background: var(--selection-color);
        padding: 2px;
        border-radius: 3px;
        order: 1;
    }

    .group-name {
    flex: 1;
    min-width: 120px; /* Добавьте это */
    padding: 0 10px;
}

    .right-controls {
    display: flex;
    gap: 5px;
}

    .group-container {
    margin-bottom: 10px;
    border: 1px solid var(--selection-color);
    border-radius: 5px;
    padding: 5px;
    background: var(--button-bg);
    width: 100%;
    box-sizing: border-box;
    overflow: hidden;
}

    .group-header {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding: 5px;    
}

    .left-controls {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

    .control-row {
    display: flex;
    gap: 5px;
}

    .group-toolbar button {
        padding: 2px 5px;
        font-size: 12px;
        background: var(--selection-color);
        border: 1px solid var(--selection-color);
        border-radius: 3px;
        color: var(--text-main);
    }

    #fileList h4 {
    margin: 10px 0 5px 0;
    color: var(--text-main);
    font-size: 14px;
}

    .object-entry:hover {
        background: rgba(0, 0, 0, 0.1);
    }

    .group-toolbar .toggle-btn,
    .group-toolbar .delete-btn {
      background: none;
      border: none;
      color: var(--text-main);
}

   .texture-entry {
    border: 1px solid var(--texture-border);
    background: var(--texture-bg);
    color: var(--texture-text);
    margin: 4px;
    padding: 4px;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s ease;
}

    .texture-entry:hover {
    background: var(--button-hover);
}

    .object-entry button {
    color: var(--text-main);
}

    .merge-btn {
    background: var(--selection-color);
    border: 1px solid var(--selection-color);
    color: var(--text-main);
    padding: 2px 5px;
    border-radius: 3px;
    cursor: pointer;
    margin-right: 3px;
}

.merge-btn:hover {
    filter: brightness(1.1);
}

    .object-entry .name {
    color: var(--text-main);
}

    .modal {
    font-family: Arial, sans-serif;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
}

.modal button {
    cursor: pointer;
    border-radius: 3px;
    transition: all 0.2s ease;
    padding: 5px 10px;
}

.modal button:hover {
    filter: brightness(0.9);
}

#addCharacterBtn:hover {
    background-color: var(--button-hover);
}

    #texture-preview {
    pointer-events: none; /* Чтобы preview не перехватывал клики */
    transition: opacity 0.2s ease; /* Плавное появление/исчезновение */
}
      
    .object-entry.selected {
        background: var(--selection-color);
    }

    #output {
        width: 100%;
        height: 100px;
        margin-top: 10px;
        background-color: var(--bg-sidebar);
        border: 1px solid var(--border-color);
        color: var(--text-main);
    }

    .toolbar {
        display: flex;
        gap: 5px;
        margin-bottom: 10px;
        padding: 5px;
        background: var(--bg-controls);
        border-bottom: 1px solid var(--border-color);
    }

    .dark-theme .object-entry {
        color: var(--text-dark);
        background-color: var(--object-bg);
        border-color: var(--object-border);
    }

    .dark-theme .group-toolbar button {
        background: #4a6da7;
        border-color: #3a5d97;
        color: var(--text-light);
    }

    .dark-theme .modal {
    background-color: var(--bg-sidebar) !important;
    color: var(--text-main) !important;
    border-color: var(--border-color) !important;
}

    .dark-theme .modal p {
    color: var(--text-main) !important;
}

    .dark-theme .modal button {
    background-color: var(--button-bg) !important;
    color: var(--text-main) !important;
    border-color: var(--border-color) !important;
}

    .dark-theme .modal button:hover {
    background-color: var(--button-hover) !important;
}

    .dark-theme #fileList h4 {
        color: var(--text-light);
    }

    .theme-toggle {
        position: fixed;
        top: 10px;
        left: 380px;
        right: auto;
        background: var(--button-bg);
        border: 1px solid var(--border-color);
        border-radius: 20px;
        padding: 5px 10px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
        z-index: 1000;
    }

    .theme-toggle i {
        font-size: 16px;
    }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <div id="styleModal">
        <div class="style-selector">
            <div class="style-title">Выберите стиль игры</div>
            <div class="style-option" data-style="topdown">
                <div>Вид сверху (Top-down)</div>
                <div><small>Подходит для RPG, стратегий</small></div>
            </div>
            <div class="style-option" data-style="sideview">
                <div>Вид сбоку (Side-view)</div>
                <div><small>Подходит для платформеров</small></div>
            </div>
        </div>
    </div>
    <input type="file" id="fileInput" style="display: none;" accept="image/*" multiple>
    <div id="sidebar">

        <div class="toolbar">
            <button onclick="document.getElementById('fileInput').click()">📁</button>
            <button id="playerStartButton" onclick="setPlayerStartMode()" title="Установить стартовую позицию игрока">🧍</button>
            <button id="groupButton" onclick="createGroupFromSelection()" title="Создать группу (Ctrl+I)">🧩</button>
            <button onclick="copySelectedObject()" title="Копировать (Ctrl+C)">⎘</button>
            <button onclick="deleteSelectedObjects()" title="Удалить (Ctrl+Del)">🗑</button>
        </div>

        <div class="sidebar-content">
        <div id="fileList"></div>
        <textarea id="output" placeholder="Здесь будет JSON карты..."></textarea>
    </div>

        <div class="sidebar-resize-handle"></div>
    </div>

    <canvas id="editorCanvas"></canvas>
    <div id="controls">
        <button onclick="zoomIn()">+</button>
        <button onclick="zoomOut()">-</button>
        <button onclick="rotateSelected(15)">↻</button>
        <button onclick="rotateSelected(-15)">↺</button>
        <span id="zoomLevel">100%</span>
        <button onclick="saveMap()">💾</button>
        <button onclick="clearScene()">🧹</button>
        <button onclick="exitEditor()">🚪</button>
    </div>

    <div class="theme-toggle" onclick="toggleTheme()">
        <i class="fas fa-moon"></i>
        <span>Тёмная тема</span>
    </div>

    <script>
         // ===== Telegram WebApp Integration =====
document.addEventListener('DOMContentLoaded', function() {
    // Инициализация Telegram WebApp
    if (window.Telegram && Telegram.WebApp) {
        // 1. Разворачиваем на весь экран
        Telegram.WebApp.expand();
        
        // 2. Получаем user_id
        const user_id = Telegram.WebApp.initDataUnsafe?.user?.id;
        console.log("User ID:", user_id); // Для отладки
        
        // 3. Применяем тему Telegram
        applyTelegramTheme();
          
        // 5. Слушаем изменения темы
        Telegram.WebApp.onEvent('themeChanged', applyTelegramTheme);
    }
    
    // Показываем модальное окно выбора стиля
    document.getElementById('styleModal').style.display = 'flex';
    
    // Обработчики для кнопок выбора стиля
    document.querySelectorAll('.style-option').forEach(option => {
        option.addEventListener('click', function() {
            selectGameStyle(this.getAttribute('data-style'));
            init();
        });
    });
});

        window.currentMapData = {};
        window.currentObjects = {};
        window.imageCache = {};
        // Весь ваш JavaScript код остается без изменений
        let resizeAnchor = "br";

        const canvas = document.getElementById("editorCanvas");
        const ctx = canvas.getContext("2d");
        const fileInput = document.getElementById("fileInput");
        const fileList = document.getElementById("fileList");
        const output = document.getElementById("output");

        let objects = [];
        let expandedStates = {}; // Хранит состояния раскрытия по src текстуры
        let zoom = 0.5;
        let tempPlayerStart = null;
        let gridSize = 64;
        let playerStartMode = false;
        const playerStartImage = new Image();
        let playMode = false;
        let selected = null;
        let multiSelected = []; // Array for multiple selection
        let dragging = false;
        let projectData = null;
        let currentMergedGroup = null;
        let resizing = false;
        let offsetX = 0, offsetY = 0;
        let cameraX = 0, cameraY = 0;
        let dragScene = false;
        let dragStartX = 0, dragStartY = 0;
        let altHeld = false;
        let imageCache = {};
        let copiedObjects = {};
        let groups = []; // Array for groups
        playerStartImage.src = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjMwIiByPSIxNSIgZmlsbD0iIzAwYzBmZiIgZmlsbC1vcGFjaXR5PSIwLjUiLz48cGF0aCBkPSJNNTAgNTBMMzAgODBMNzAgODBaIiBmaWxsPSIjMDBjMGZmIiBmaWxsLW9wYWNpdHk9IjAuNSIvPjwvc3ZnPg==';
        let gameStyle = 'topdown';
        let telegramThemeParams = null;
        let isProcessingFiles = false;

       // 3. Применяем тему Telegram
            function applyTelegramTheme() {
    if (window.Telegram && Telegram.WebApp) {
        telegramThemeParams = Telegram.WebApp.themeParams || {};
        
        // Применяем тему Telegram
        if (Telegram.WebApp.colorScheme === 'dark' || 
            telegramThemeParams.bg_color === '#212121') {
            document.body.classList.add('dark-theme');
        } else {
            document.body.classList.remove('dark-theme');
        }
        
        // Обновляем переключатель темы
        if (window.updateThemeToggle) {
            updateThemeToggle();
        }
        
        // Перерисовываем интерфейс
        draw();
    }
}

class UndoManager {
    constructor(maxSteps = 10) {
        this.maxSteps = maxSteps;
        this.undoStack = [];
        this.redoStack = [];
    }

    addAction(action) {
        this.undoStack.push(action);
        if (this.undoStack.length > this.maxSteps) {
            this.undoStack.shift();
        }
        this.redoStack = []; // Очищаем redo при новом действии
    }

    undo() {
        if (this.undoStack.length === 0) return null;
        
        const action = this.undoStack.pop();
        this.redoStack.push(action);
        return action;
    }

    redo() {
        if (this.redoStack.length === 0) return null;
        
        const action = this.redoStack.pop();
        this.undoStack.push(action);
        return action;
    }

    clear() {
        this.undoStack = [];
        this.redoStack = [];
    }
}

// Создаем экземпляр менеджера отмены
const undoManager = new UndoManager(10);

// Функция для сохранения состояния редактора
function saveState() {
    return {
        objects: JSON.parse(JSON.stringify(objects)),
        groups: JSON.parse(JSON.stringify(groups)),
        selected: selected ? {...selected} : null,
        multiSelected: [...multiSelected],
        cameraX, cameraY, zoom
    };
}

// Добавляем скрипты библиотек в head документа
function loadScript(src) {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

// Инициализация библиотек при загрузке
async function initExportLibraries() {
    try {
        await Promise.all([
            loadScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'),
            loadScript('https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js')
        ]);
        console.log('Export libraries loaded');
    } catch (e) {
        console.error('Error loading export libraries:', e);
    }
}

async function exportProjectToZip() {
    // Проверяем, загружены ли библиотеки
    if (typeof JSZip === 'undefined' || typeof saveAs === 'undefined') {
        await initExportLibraries();
    }

    // Запрашиваем имя проекта у пользователя
    const projectName = await showPromptModal({
        title: 'Экспорт проекта',
        message: 'Введите имя для проекта:',
        defaultValue: 'my_game_project',
        showCancel: true,
        confirmText: 'Экспорт',
        cancelText: 'Отмена'
    });

    if (!projectName) return;

    // Создаем индикатор прогресса
    const progress = showProgress(0, 'Подготовка данных...');

    try {
        // Создаем новый ZIP-архив
        const zip = new JSZip();
        const projectFolder = zip.folder(projectName);

        // 1. Сохраняем данные карты (map.json)
        progress.update(10, 'Сохранение карты...');
        const mapData = saveMap();
        projectFolder.file('map.json', mapData);

        // 2. Сохраняем текстуры
        progress.update(20, 'Сохранение текстур...');
        const texturesFolder = projectFolder.folder('textures');
        
        let textureCount = 0;
        const totalTextures = Object.keys(imageCache).length;
        
        for (const [textureName, img] of Object.entries(imageCache)) {
            // Конвертируем Data URL в blob
            const blob = dataURLToBlob(img.src);
            
            // Получаем расширение файла из data URL
            const match = img.src.match(/^data:image\/(\w+);/);
            const ext = match ? match[1] : 'png';
            
            // Добавляем файл в архив
            texturesFolder.file(`${textureName}.${ext}`, blob);
            
            textureCount++;
            progress.update(20 + Math.floor((textureCount / totalTextures) * 30), `Сохранение текстур (${textureCount}/${totalTextures})...`);
        }

        // 3. Сохраняем объекты
        progress.update(60, 'Сохранение объектов...');
        const objectsFolder = projectFolder.folder('objects');
        
        objects.forEach((obj, index) => {
            const safeName = obj.name 
                ? obj.name.replace(/[^a-z0-9]/gi, '_').toLowerCase() 
                : `object_${index}`;
                
            const objData = JSON.stringify(obj, null, 2);
            objectsFolder.file(`${safeName}.json`, objData);
        });

        // 4. Сохраняем группы (если есть)
        if (groups.length > 0) {
            progress.update(80, 'Сохранение групп...');
            const groupsFolder = projectFolder.folder('groups');
            
            groups.forEach((group, index) => {
                const safeName = group.name 
                    ? group.name.replace(/[^a-z0-9]/gi, '_').toLowerCase() 
                    : `group_${index}`;
                    
                const groupData = JSON.stringify(group, null, 2);
                groupsFolder.file(`${safeName}.json`, groupData);
            });
        }

        // Генерируем ZIP-архив
        progress.update(90, 'Создание архива...');
        const content = await zip.generateAsync({ type: 'blob' }, (metadata) => {
            progress.update(90 + Math.floor(metadata.percent / 10),`Создание архива (${metadata.percent.toFixed(1)}%)...`);
        });

        // Сохраняем архив
        progress.update(100, 'Сохранение архива...');
        saveAs(content, `${projectName}.zip`);

    } catch (error) {
        console.error('Ошибка при экспорте проекта:', error);
        showAlert('Ошибка при экспорте проекта: ' + error.message, 'Ошибка');
    } finally {
        progress.hide();
    }
}

function clearUnusedTextures() {
    const usedTextures = new Set();
    
    // Собираем используемые текстуры
    objects.forEach(obj => usedTextures.add(obj.src));
    groups.forEach(group => {
        group.objects.forEach(obj => usedTextures.add(obj.src));
    });
    
    // Удаляем неиспользуемые
    Object.keys(imageCache).forEach(textureName => {
        if (!usedTextures.has(textureName)) {
            delete imageCache[textureName];
        }
    });
    
    updateSidebar();
}

function rotateSelected(degrees) {
    if (selected) {
        selected.rotation = (selected.rotation || 0) + degrees * Math.PI/180;
        draw();
    }
}

// Функция для восстановления состояния редактора
function restoreState(state) {
    objects = JSON.parse(JSON.stringify(state.objects));
    groups = JSON.parse(JSON.stringify(state.groups));
    selected = state.selected ? {...state.selected} : null;
    multiSelected = [...state.multiSelected];
    cameraX = state.cameraX;
    cameraY = state.cameraY;
    zoom = state.zoom;
    
    updateSidebar();
    draw();
    updateZoomDisplay();
}

// Функция для применения темы Telegram
function applyTheme(themeParams) {
    if (themeParams) {
        // Пример применения темы - настройте под ваш редактор
        const isDark = themeParams.bg_color === '#212121';
        if (isDark) {
            document.body.classList.add('dark-theme');
        } else {
            document.body.classList.remove('dark-theme');
        }
    }
}

// Функция для получения данных карты
function getMapData() {
    // Используйте вашу существующую логику экспорта
    return {
        style: gameStyle,
        objects: objects,
        gridSize: gridSize
    };
}

// Применяем сохранённую тему Telegram при загрузке
if (window.telegramThemeParams) {
    applyTheme(window.telegramThemeParams);
}

// Модифицируем основные функции для сохранения состояния
function wrapWithUndo(fn) {
    return function(...args) {
        const beforeState = saveState();
        const result = fn.apply(this, args);
        const afterState = saveState();
        
        // Добавляем действие в историю только если состояние изменилось
        if (JSON.stringify(beforeState) !== JSON.stringify(afterState)) {
            undoManager.addAction({
                undo: () => restoreState(beforeState),
                redo: () => restoreState(afterState)
            });
        }
        
        return result;
    };
}
        let ctrlHeld = false; // Track if Ctrl key is held
        let keyState = {};
          const moveSpeed = {
          base: gridSize,
          accelerated: gridSize * 3,
          precise: 1
        };
        let lastMoveTime = 0;

        // Основные функции
        function resizeCanvas() {
    const ratio = window.devicePixelRatio || 1;
    const sidebar = document.getElementById('sidebar');
    const sidebarWidth = sidebar.offsetWidth;
    const width = window.innerWidth - sidebarWidth;
    const height = window.innerHeight;
    
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
    canvas.width = width * ratio;
    canvas.height = height * ratio;
    
    // Устанавливаем начальный масштаб, при котором сетка хорошо видна
    zoom = Math.min(1, Math.max(0.5, 800 / Math.max(width, height) // Автоподбор масштаба под размер окна
    ));
    
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(ratio, ratio);
    
    draw();
    updateZoomDisplay();
}   

        function mergeGroupObjects(group) {
    if (group.merged) {
        unmergeGroup(group);
        return;
    }
    
    // Рассчитываем общие границы группы
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    group.objects.forEach(obj => {
        minX = Math.min(minX, obj.x);
        minY = Math.min(minY, obj.y);
        maxX = Math.max(maxX, obj.x + obj.w);
        maxY = Math.max(maxY, obj.y + obj.h);
    });
    
    // Сохраняем исходные позиции и размеры относительно группы
    group.originalState = {
        width: maxX - minX,
        height: maxY - minY,
        objects: group.objects.map(obj => ({
            x: obj.x,
            y: obj.y,
            w: obj.w,
            h: obj.h,
            relX: (obj.x - minX) / (maxX - minX),
            relY: (obj.y - minY) / (maxY - minY),
            relW: obj.w / (maxX - minX),
            relH: obj.h / (maxY - minY)
        }))
    };
    
    // Создаем объединенный объект
    group.mergedObject = {
        x: minX,
        y: minY,
        w: maxX - minX,
        h: maxY - minY,
        visible: true
    };
    
    group.merged = true;
    currentMergedGroup = group;
    updateSidebar();
    draw();
}

        function selectGameStyle(style) {
    gameStyle = style;
    document.getElementById('styleModal').style.display = 'none';
    
    // Обновляем UI в соответствии с выбранным стилем
    const styleIndicator = document.createElement('div');
    styleIndicator.id = 'style-indicator';
    styleIndicator.style.position = 'fixed';
    styleIndicator.style.top = '10px';
    styleIndicator.style.right = '10px';
    styleIndicator.style.background = 'var(--button-bg)';
    styleIndicator.style.padding = '2px 6px';
    styleIndicator.style.borderRadius = '3px';
    styleIndicator.style.zIndex = '1000';
    styleIndicator.textContent = `Стиль: ${style === 'sideview' ? 'Вид сбоку' : 'Вид сверху'}`;
    
    // Удаляем старый индикатор, если есть
    const oldIndicator = document.getElementById('style-indicator');
    if (oldIndicator) oldIndicator.remove();
    
    document.body.appendChild(styleIndicator);
    
    draw();
}

        // Функция для создания кастомного модального окна
function showModal(options) {
    return new Promise((resolve) => {
        if (window.Telegram && Telegram.WebApp) {
            Telegram.WebApp.expand();
        }
        const isDark = document.body.classList.contains('dark-theme');
        const modalId = 'modal-' + Date.now();
        
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.id = modalId;
        modal.style.zIndex = '10000';
        
        const content = document.createElement('div');
        content.className = 'modal-content';
        
        if (options.title) {
            const title = document.createElement('h3');
            title.className = 'modal-title';
            title.textContent = options.title;
            content.appendChild(title);
        }
        
        const message = document.createElement('div');
        message.className = 'modal-message';
        message.textContent = options.message;
        content.appendChild(message);
        
        const buttons = document.createElement('div');
        buttons.className = 'modal-buttons';
        
        if (options.showCancel) {
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'modal-button modal-button-cancel';
            cancelBtn.textContent = options.cancelText || 'Отмена';
            cancelBtn.onclick = () => {
                document.body.removeChild(modal);
                resolve(false);
            };
            buttons.appendChild(cancelBtn);
        }
        
        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'modal-button modal-button-confirm';
        confirmBtn.textContent = options.confirmText || 'OK';
        confirmBtn.onclick = () => {
            document.body.removeChild(modal);
            resolve(true);
        };
        buttons.appendChild(confirmBtn);
        
        content.appendChild(buttons);
        modal.appendChild(content);
        document.body.appendChild(modal);
        confirmBtn.focus();
        
        // Убедимся, что WebApp не свернется
        if (window.Telegram && Telegram.WebApp) {
            Telegram.WebApp.expand();
        }
    });
}

         function showLoadingIndicator() {
    const loader = document.createElement('div');
    loader.id = 'file-loader';
    loader.innerHTML = 'Загрузка...';
    loader.style.position = 'fixed';
    loader.style.top = '50%';
    loader.style.left = '50%';
    loader.style.transform = 'translate(-50%, -50%)';
    loader.style.padding = '10px 20px';
    loader.style.background = 'var(--bg-sidebar)';
    loader.style.border = '1px solid var(--border-color)';
    loader.style.zIndex = '10000';
    document.body.appendChild(loader);
}

function hideLoadingIndicator() {
    const loader = document.getElementById('file-loader');
    if (loader) loader.remove();
}

        async function compressImage(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const MAX_WIDTH = 1024;
                const MAX_HEIGHT = 1024;
                let width = img.width;
                let height = img.height;

                if (width > MAX_WIDTH) {
                    height *= MAX_WIDTH / width;
                    width = MAX_WIDTH;
                }
                if (height > MAX_HEIGHT) {
                    width *= MAX_HEIGHT / height;
                    height = MAX_HEIGHT;
                }

                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);

                canvas.toBlob((blob) => {
                    resolve(blob);
                }, 'image/jpeg', 0.7); // Качество 70%
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });
}

// Функция для отображения прогресса
function showProgress(percent, message) {
    let progressContainer = document.getElementById('progress-container');
    
    if (!progressContainer) {
        progressContainer = document.createElement('div');
        progressContainer.id = 'progress-container';
        Object.assign(progressContainer.style, {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            background: 'rgba(0,0,0,0.7)',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center',
            zIndex: '9999'
        });

        const progressBox = document.createElement('div');
        Object.assign(progressBox.style, {
            background: 'white',
            padding: '20px',
            borderRadius: '8px',
            width: '300px',
            textAlign: 'center'
        });

        const progressText = document.createElement('div');
        progressText.id = 'progress-text';
        progressText.textContent = message;
        progressText.style.marginBottom = '10px';

        const progressBarBg = document.createElement('div');
        Object.assign(progressBarBg.style, {
            width: '100%',
            height: '10px',
            background: '#f0f0f0',
            borderRadius: '5px',
            overflow: 'hidden'
        });

        const progressBar = document.createElement('div');
        progressBar.id = 'progress-bar';
        Object.assign(progressBar.style, {
            height: '100%',
            width: `${percent}%`,
            background: '#4CAF50',
            transition: 'width 0.3s'
        });

        progressBarBg.appendChild(progressBar);
        progressBox.appendChild(progressText);
        progressBox.appendChild(progressBarBg);
        progressContainer.appendChild(progressBox);
        document.body.appendChild(progressContainer);
    } else {
        const progressText = document.getElementById('progress-text');
        const progressBar = document.getElementById('progress-bar');
        progressText.textContent = message;
        progressBar.style.width = `${percent}%`;
    }

    return {
        update: (newPercent, newMessage) => {
            showProgress(newPercent, newMessage);
        },
        hide: () => {
            if (progressContainer) {
                progressContainer.style.opacity = '0';
                setTimeout(() => progressContainer.remove(), 300);
            }
        }
    };
}

// Функция для отправки измененных текстур
async function sendTextures(texturesToSend) {
    if (!texturesToSend.length) return;
    
    const batchSize = 5; // Лимит Telegram на количество файлов
    for (let i = 0; i < texturesToSend.length; i += batchSize) {
        const batch = texturesToSend.slice(i, i + batchSize);
        await Promise.all(batch.map(texture => {
            const blob = dataURLToBlob(texture.data);
            const file = new File([blob], texture.name, { type: `image/${texture.format}` });
            return Telegram.WebApp.sendData(JSON.stringify({
                type: "texture",
                name: texture.name,
                file: file.name
            }));
        }));
    }
}

// Вспомогательная функция для конвертации Data URL в Blob
function dataURLToBlob(dataURL) {
    const parts = dataURL.split(',');
    const mime = parts[0].match(/:(.*?);/)[1];
    const bstr = atob(parts[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    
    while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
    }
    
    return new Blob([u8arr], { type: mime });
}

// Получаем список измененных текстур
function updateTextureList() {
    const textures = [];
    Object.keys(imageCache).forEach(name => {
        const img = imageCache[name];
        if (img.src.startsWith('data:')) { // Только новые/измененные текстуры
            textures.push({
                name: name,
                data: img.src,
                format: img.src.split(';')[0].split('/')[1]
            });
        }
    });
    return textures;
}

        function exportToFile() {
    const data = saveMap();
    const blob = new Blob([data], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'map.json';
    a.click();
}

        // Функция для показа модального окна с полем ввода
function showPromptModal(options) {
    return new Promise((resolve) => {
        const modalId = 'modal-' + Date.now();
        
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.id = modalId;
        
        const content = document.createElement('div');
        content.className = 'modal-content';
        
        if (options.title) {
            const title = document.createElement('h3');
            title.className = 'modal-title';
            title.textContent = options.title;
            content.appendChild(title);
        }
        
        const message = document.createElement('div');
        message.className = 'modal-message';
        message.textContent = options.message;
        content.appendChild(message);
        
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'modal-input';
        input.style.width = '100%';
        input.style.padding = '8px';
        input.style.margin = '10px 0';
        input.style.border = '1px solid var(--border-color)';
        input.style.borderRadius = '3px';
        input.style.backgroundColor = 'var(--bg-canvas)';
        input.style.color = 'var(--text-main)';
        if (options.defaultValue) input.value = options.defaultValue;
        content.appendChild(input);
        
        const buttons = document.createElement('div');
        buttons.className = 'modal-buttons';
        
        if (options.showCancel) {
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'modal-button modal-button-cancel';
            cancelBtn.textContent = options.cancelText || 'Отмена';
            cancelBtn.onclick = () => {
                document.body.removeChild(modal);
                resolve(null);
            };
            buttons.appendChild(cancelBtn);
        }
        
        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'modal-button modal-button-confirm';
        confirmBtn.textContent = options.confirmText || 'OK';
        confirmBtn.onclick = () => {
            document.body.removeChild(modal);
            resolve(input.value);
        };
        buttons.appendChild(confirmBtn);
        
        content.appendChild(buttons);
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        input.focus();
        
        // Обработка нажатия Enter
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.body.removeChild(modal);
                resolve(input.value);
            }
        });
        
        if (window.Telegram && Telegram.WebApp) {
            Telegram.WebApp.expand();
        }
    });
}

        // Функция для показа информационного сообщения
function showAlert(message, title = 'Сообщение') {
    return showModal({
        title: title,
        message: message,
        showCancel: false
    });
}

// Убедимся, что WebApp развернут перед действиями
function ensureWebAppExpanded() {
    if (window.Telegram && Telegram.WebApp) {
        Telegram.WebApp.expand();
    }
}

        function updateThemeToggle() {
            const isDark = document.body.classList.contains('dark-theme');
            const toggle = document.querySelector('.theme-toggle');
            toggle.innerHTML = isDark 
                ? '<i class="fas fa-sun"></i><span>Светлая тема</span>' 
                : '<i class="fas fa-moon"></i><span>Тёмная тема</span>';
        }

        function unmergeObject(mergedObject) {
    if (!mergedObject?.isMerged) return;
    
    // 1. Возвращаем оригинальные объекты
    mergedObject.originalObjects.forEach(obj => {
        objects.push(obj);
    });
    
    // 2. Удаляем объединенный объект
    const index = objects.indexOf(mergedObject);
    if (index !== -1) objects.splice(index, 1);
    
    // 3. Обновляем интерфейс
    selected = null;
    multiSelected = [];
    updateSidebar();
    draw();
}

// Добавьте кнопку разъединения в свойствах объекта
if (selected?.isMerged) {
    const unmergeBtn = document.createElement("button");
    unmergeBtn.textContent = "Разъединить";
    unmergeBtn.onclick = () => unmergeObject(selected);
    // Добавьте кнопку в интерфейс
}

        function unmergeGroup(group) {
    if (!group.merged) return;
    
    // Просто сбрасываем флаг объединения
    group.merged = false;
    group.mergedObject = null;
    
    draw();
}
        // Проверяем сохранённую тему при загрузке
        function initTheme() {
            const savedTheme = localStorage.getItem('editorTheme') || 'light';
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-theme');
            }
            updateThemeToggle();
        }  

        // Функция для включения/выключения режима установки стартовой позиции
        function setPlayerStartMode() {
            playerStartMode = !playerStartMode;
            const btn = document.getElementById('playerStartButton');
            
            if (playerStartMode) {
                btn.style.backgroundColor = 'var(--selection-color)';
                tempPlayerStart = {
                    x: 0,
                    y: 0,
                    w: gridSize,
                    h: gridSize,
                    type: "playerStart",
                    visible: true
                };
            } else {
                btn.style.backgroundColor = '';
                tempPlayerStart = null;
            }
            draw();
        }

        // Добавим функцию проверки имени текстуры
    function isValidTextureName(name) {
    return /^[a-z0-9_-]+$/.test(name);
}

function renameTexture(oldName, newName) {
    if (!isValidTextureName(newName)) {
        alert("Недопустимое имя текстуры. Можно использовать только английские буквы, цифры, дефисы и подчеркивания.");
        return false;
    }

    if (oldName === newName) return true;

    if (!imageCache[oldName]) {
        console.error("Текстура не найдена в кеше:", oldName);
        return false;
    }

    // Обновляем imageCache
    imageCache[newName] = imageCache[oldName];
    delete imageCache[oldName];

    // Обновляем объекты и группы
    [objects, ...groups.map(g => g.objects)].flat().forEach(obj => {
        if (obj.src === oldName) {
            obj.src = newName;
            if (obj.name === oldName) obj.name = newName;
        }
    });

    updateSidebar();
    draw();
    return true;
}
    // Функция для отображения UI переименования
    async function showRenameTextureDialog(textureName) {
    ensureWebAppExpanded();
    
    if (!textureName || !imageCache[textureName]) {
        console.error("Неверное имя текстуры:", textureName);
        return;
    }
    
    const newName = await showPromptModal({
        title: 'Переименовать текстуру',
        message: 'Введите новое имя для текстуры:',
        defaultValue: textureName,
        showCancel: true,
        confirmText: 'Переименовать',
        cancelText: 'Отмена'
    });
    
    if (newName && newName !== textureName) {
        if (!isValidTextureName(newName)) {
            await showAlert('Недопустимое имя текстуры. Можно использовать только английские буквы, цифры, дефисы и подчеркивания.', 'Ошибка');
            return;
        }
        
        renameTexture(textureName, newName);
    }
}      
        function showAddToGroupModal(targetGroup) {
    const isDark = document.body.classList.contains('dark-theme');
    const modal = document.createElement('div');
    modal.className = `modal ${isDark ? 'dark-theme' : ''}`;
    
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.backgroundColor = isDark ? 'var(--bg-sidebar)' : 'white';
    modal.style.color = isDark ? 'var(--text-main)' : 'black';
    modal.style.padding = '20px';
    modal.style.border = `1px solid ${isDark ? 'var(--border-color)' : '#ccc'}`;
    modal.style.borderRadius = '5px';
    modal.style.zIndex = '1000';
    modal.style.minWidth = '300px';
    modal.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';

    const message = document.createElement('p');
    message.textContent = `Добавить выбранные объекты в группу "${targetGroup.name}"?`;
    message.style.margin = '0 0 15px 0';
    message.style.color = isDark ? 'var(--text-main)' : 'inherit';

    const buttonsContainer = document.createElement('div');
    buttonsContainer.style.display = 'flex';
    buttonsContainer.style.justifyContent = 'flex-end';
    buttonsContainer.style.gap = '10px';

    const confirmBtn = document.createElement('button');
    confirmBtn.textContent = 'Добавить';
    confirmBtn.style.padding = '5px 10px';
    confirmBtn.style.background = isDark ? 'var(--button-bg)' : '#f0f0f0';
    confirmBtn.style.color = isDark ? 'var(--text-main)' : 'inherit';
    confirmBtn.style.border = `1px solid ${isDark ? 'var(--border-color)' : '#ccc'}`;

    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Отмена';
    cancelBtn.style.padding = '5px 10px';
    cancelBtn.style.background = isDark ? 'var(--button-bg)' : '#f0f0f0';
    cancelBtn.style.color = isDark ? 'var(--text-main)' : 'inherit';
    cancelBtn.style.border = `1px solid ${isDark ? 'var(--border-color)' : '#ccc'}`;

    buttonsContainer.appendChild(confirmBtn);
    buttonsContainer.appendChild(cancelBtn);
    modal.appendChild(message);
    modal.appendChild(buttonsContainer);
    document.body.appendChild(modal);

    confirmBtn.onclick = () => {
        const objectsToAdd = selected ? [selected] : [...multiSelected];
        objectsToAdd.forEach(obj => {
            if (!targetGroup.objects.includes(obj)) {
                targetGroup.objects.push(obj);
            }
        });
        updateSidebar();
        draw();
        document.body.removeChild(modal);
    };

    cancelBtn.onclick = () => {
        document.body.removeChild(modal);
    };
}

        function isTelegramWebApp() {
    return !!(window.Telegram && Telegram.WebApp);
}
        function findCopiesOf(originalObj) {
    if (!originalObj) return [];
    return objects.filter(obj => 
        obj !== originalObj && 
        obj.src === originalObj.src && 
        obj.isCopy
    );
}

        function updateGridSize() {
    // Автоподбор размера сетки в зависимости от масштаба
    if (zoom < 0.3) {
        gridSize = 128;
    } else if (zoom < 0.6) {
        gridSize = 64;
    } else if (zoom < 1.2) {
        gridSize = 32;
    } else {
        gridSize = 16;
    }
}

        async function exportProjectToDisk() {
    // Создаем папку для проекта
    const projectName = prompt("Введите имя проекта для экспорта", "my_game_project") || "my_game_project";
    
    // 1. Сохраняем карту (map.json)
    const mapData = saveMap();
    await downloadFile(`${projectName}/map.json`, new Blob([mapData], { type: 'application/json' }));
    
    // 2. Сохраняем текстуры
    for (const [textureName, img] of Object.entries(imageCache)) {
        const blob = dataURLToBlob(img.src);
        const ext = img.src.split(';')[0].split('/')[1];
        await downloadFile(`${projectName}/textures/${textureName}.${ext}`, blob);
    }
    
    // 3. Сохраняем объекты
    for (const obj of objects) {
        const objName = obj.name.replace(/[^a-z0-9]/gi, '_').toLowerCase() || `object_${objects.indexOf(obj)}`;
        const objData = JSON.stringify(obj, null, 2);
        await downloadFile(`${projectName}/objects/${objName}.json`, new Blob([objData], { type: 'application/json' }));
    }
    
    // 4. Сохраняем группы (если есть)
    if (groups.length > 0) {
        for (const group of groups) {
            const groupName = group.name.replace(/[^a-z0-9]/gi, '_').toLowerCase() || `group_${groups.indexOf(group)}`;
            const groupData = JSON.stringify(group, null, 2);
            await downloadFile(`${projectName}/groups/${groupName}.json`, new Blob([groupData], { type: 'application/json' }));
        }
    }
    
    alert(`Проект "${projectName}" успешно экспортирован!`);
}

// Вспомогательная функция для скачивания файла
function downloadFile(filename, blob) {
    return new Promise((resolve) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            resolve();
        }, 300);
    });
}



        function updateZoomDisplay() {
    const zoomLevelElement = document.getElementById('zoomLevel');
    const percentage = Math.round(zoom * 100);
    zoomLevelElement.textContent = `${percentage}%`;
   
    // Добавим анимацию для наглядности
    zoomLevelElement.style.transform = 'scale(1.2)';
    setTimeout(() => {
        zoomLevelElement.style.transform = 'scale(1)';
    }, 200);
}

// =============================================
// Функция для создания ZIP-архива из проекта
// =============================================
async function createProjectZip() {
  // 1. Получаем данные карты в JSON
  const mapData = saveMap();
  
  // 2. Создаём ZIP-архив
  const zip = new JSZip();
  
  // 3. Добавляем файл карты
  zip.file("map.json", mapData);
  
  // 4. Добавляем текстуры
  if (Object.keys(imageCache).length > 0) {
    const texturesFolder = zip.folder("textures");
    for (const [name, img] of Object.entries(imageCache)) {
      const blob = dataURLToBlob(img.src);
      const match = img.src.match(/^data:image\/(\w+);/);
      const ext = match ? match[1] : 'png';
      texturesFolder.file(`${name}.${ext}`, blob);
    }
  }
  
  // 5. Добавляем объекты
  if (objects.length > 0) {
    const objectsFolder = zip.folder("objects");
    objects.forEach((obj, index) => {
      const safeName = obj.name 
        ? obj.name.replace(/[^a-z0-9]/gi, '_').toLowerCase() 
        : `object_${index}`;
      objectsFolder.file(`${safeName}.json`, JSON.stringify(obj, null, 2));
    });
  }
  
  // 6. Добавляем группы (если есть)
  if (groups.length > 0) {
    const groupsFolder = zip.folder("groups");
    groups.forEach((group, index) => {
      const safeName = group.name 
        ? group.name.replace(/[^a-z0-9]/gi, '_').toLowerCase() 
        : `group_${index}`;
      groupsFolder.file(`${safeName}.json`, JSON.stringify(group, null, 2));
    });
  }
  
  // 7. Генерируем ZIP и возвращаем как Blob
  return await zip.generateAsync({ type: "blob" });
}

// =============================================
// Функция для отправки ZIP на сервер
// =============================================
async function uploadToServer(zipBlob) {
  try {
    // Получаем параметры из URL
    const urlParams = new URLSearchParams(window.location.search);
    const projectName = urlParams.get('project');
    const userId = urlParams.get('user_id') || Telegram.WebApp.initDataUnsafe?.user?.id;

    if (!projectName || !userId) {
      throw new Error("Не удалось определить проект для сохранения. Откройте редактор через бота.");
    }

    const formData = new FormData();
    formData.append('file', zipBlob, `${projectName}.zip`);
    formData.append('user_id', userId);
    formData.append('project_name', projectName); // Используем имя из URL

    // Статистика
    formData.append('textures_count', Object.keys(imageCache).length);
    formData.append('objects_count', objects.length);
    formData.append('groups_count', groups.length);

    const response = await fetch('/upload', {
      method: 'POST',
      body: formData
    });
    
    return await response.json();
  } catch (error) {
    console.error('Ошибка при сохранении проекта:', error);
    throw error;
  }
}
// =============================================
// Кнопка "Сохранить на сервере" (добавить в HTML!)
// =============================================
function setupSaveButton() {
  const saveBtn = document.createElement('button');
  saveBtn.id = 'saveToServerBtn';
  saveBtn.textContent = '💾 Сохранить в проект';
  
  saveBtn.addEventListener('click', async () => {
    try {
      showLoadingIndicator();
      const zipBlob = await createProjectZip();
      await uploadToServer(zipBlob);
      showAlert('✅ Проект успешно сохранён!');
    } catch (error) {
      showAlert(`❌ Ошибка: ${error.message}`);
    } finally {
      hideLoadingIndicator();
    }
  });

  document.body.appendChild(saveBtn);
}

      function drawGrid() {
    const ratio = window.devicePixelRatio || 1;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    
    const LINE_COLOR = getComputedStyle(document.body).getPropertyValue('--grid-color').trim();
    const LINE_WIDTH = 1;
    
    ctx.strokeStyle = LINE_COLOR;
    ctx.lineWidth = LINE_WIDTH / ratio;
    
    const visibleLeft = cameraX;
    const visibleTop = cameraY;
    const visibleRight = visibleLeft + canvas.width / (zoom * ratio);
    const visibleBottom = visibleTop + canvas.height / (zoom * ratio);
    
    // Всегда рисуем одну и ту же сетку, независимо от стиля
    drawGridLines(visibleLeft, visibleTop, visibleRight, visibleBottom, gridSize);
    
    ctx.restore();
}

function drawGridLines(left, top, right, bottom, size) {
    // Горизонтальные линии
    const startY = Math.floor(top / size) * size;
    for (let y = startY; y <= bottom; y += size) {
        const screenY = (y - cameraY) * zoom;
        ctx.beginPath();
        ctx.moveTo(0, screenY);
        ctx.lineTo(canvas.width, screenY);
        ctx.stroke();
    }
    
    // Вертикальные линии
    const startX = Math.floor(left / size) * size;
    for (let x = startX; x <= right; x += size) {
        const screenX = (x - cameraX) * zoom;
        ctx.beginPath();
        ctx.moveTo(screenX, 0);
        ctx.lineTo(screenX, canvas.height);
        ctx.stroke();
    }
}
         function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();

            // 1. Рисуем все обычные объекты (кроме playerStart)
            for (const obj of objects.filter(o => o.type !== "playerStart")) {
                if (!obj.visible) continue;
                
                const img = imageCache[obj.src];
                if (img) {
                    const x = (obj.x - cameraX) * zoom;
                    const y = (obj.y - cameraY) * zoom;
                    const w = obj.w * zoom;
                    const h = obj.h * zoom;
                    
                    ctx.save();
                    ctx.translate(x + w/2, y + h/2);
                    ctx.rotate(obj.rotation || 0);
                    ctx.scale(obj.scaleX || 1, obj.scaleY || 1);
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(img, -w/2, -h/2, w, h);
                    ctx.restore();
                    
                    // Выделение
                    if (obj === selected) {
                        ctx.strokeStyle = "red";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, w, h);
                        
                        // Маркеры для ресайза
                        ctx.fillStyle = "red";
                        ctx.fillRect(x + w - 8, y + h - 8, 8, 8);
                    } 
                    else if (multiSelected.includes(obj)) {
                        ctx.strokeStyle = "blue";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, w, h);
                    }
                }
            }

            // 2. Рисуем временную стартовую позицию (если в режиме установки)
            if (playerStartMode && tempPlayerStart) {
                const x = (tempPlayerStart.x - cameraX) * zoom;
                const y = (tempPlayerStart.y - cameraY) * zoom;
                const w = tempPlayerStart.w * zoom;
                const h = tempPlayerStart.h * zoom;
                
                ctx.save();
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(playerStartImage, x, y, w, h);
                ctx.restore();
                
                ctx.strokeStyle = "#00c0ff";
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
            }

            // 3. Рисуем постоянную стартовую позицию (поверх всех объектов)
            const existingPlayerStart = objects.find(o => o.type === "playerStart");
            if (existingPlayerStart && existingPlayerStart.visible) {
                const x = (existingPlayerStart.x - cameraX) * zoom;
                const y = (existingPlayerStart.y - cameraY) * zoom;
                const w = existingPlayerStart.w * zoom;
                const h = existingPlayerStart.h * zoom;
                
                ctx.save();
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(playerStartImage, x, y, w, h);
                ctx.restore();
                
                if (existingPlayerStart === selected) {
                    ctx.strokeStyle = "red";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, w, h);
                    
                    ctx.fillStyle = "red";
                    ctx.fillRect(x + w - 8, y + h - 8, 8, 8);
                }
            }

            // 4. Рисуем объединенные группы
            groups.forEach(group => {
                if (group.merged && group.mergedObject && group.mergedObject.visible) {
                    const x = (group.mergedObject.x - cameraX) * zoom;
                    const y = (group.mergedObject.y - cameraY) * zoom;
                    const w = group.mergedObject.w * zoom;
                    const h = group.mergedObject.h * zoom;
                    
                    ctx.strokeStyle = "#4a6da7";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, w, h);
                    
                    if (group === currentMergedGroup) {
                        ctx.fillStyle = "#4a6da7";
                        ctx.fillRect(x + w - 8, y + h - 8, 8, 8);
                    }
                }
            });
        }
 
        function copySelectedObject() {
            if (!selected) return;
            
            const copy = JSON.parse(JSON.stringify(selected));
            copy.x += gridSize;
            copy.y += gridSize;
            copy.name = `${selected.name.replace(/ \(\d+\)$/, "")} (${(copiedObjects[selected.src]?.length || 0) + 1})`;
            copy.isCopy = true;
            
            if (!copiedObjects[selected.src]) {
                copiedObjects[selected.src] = [];
            }
            copiedObjects[selected.src].push(copy);
            objects.push(copy);
            selected = copy;
            updateSidebar();
            draw();
        }

        function createGroupFromSelection() {
            if (multiSelected.length === 0 && !selected) return;
            
            const groupObjects = selected ? [selected, ...multiSelected] : [...multiSelected];
            
            const group = {
                id: Date.now().toString(),
                name: `Group ${groups.length + 1}`,
                objects: groupObjects,
                expanded: true
            };
            
            groups.push(group);
            
            // Clear selection
            selected = null;
            multiSelected = [];
            
            updateSidebar();
            draw();
        }

        async function deleteSelectedObjects() {
    ensureWebAppExpanded();
    
    if (selected) {
        const shouldDelete = await showModal({
            title: 'Удаление объекта',
            message: selected.isCopy ? 
                'Удалить эту копию?' : 
                `Удалить этот объект и все его копии (${findCopiesOf(selected).length})?`,
            showCancel: true,
            confirmText: 'Удалить',
            cancelText: 'Отмена'
        });
        
        if (!shouldDelete) return;
        
        const currentSrc = selected.src;
        const wasExpanded = expandedStates[currentSrc];
        const copies = findCopiesOf(selected);
        
        objects = objects.filter(obj => 
            obj !== selected && 
            !copies.includes(obj)
        );
        
        groups.forEach(group => {
            group.objects = group.objects.filter(obj => 
                obj !== selected && 
                !copies.includes(obj)
            );
        });
        
        groups = groups.filter(g => g.objects.length > 0);
        
        if (selected && (selected.src === currentSrc || copies.includes(selected))) {
    selected = null;
}
        multiSelected = multiSelected.filter(o => 
            o !== selected && 
            !copies.includes(o)
        );
        
        if (copies.length === 0) {
            delete expandedStates[currentSrc];
        }
        
        updateSidebar();
        draw();
    }
    
    if (multiSelected.length > 0) {
        const shouldDelete = await showModal({
            title: 'Удаление объектов',
            message: `Удалить ${multiSelected.length} выбранных объектов?`,
            showCancel: true,
            confirmText: 'Удалить',
            cancelText: 'Отмена'
        });
        
        if (!shouldDelete) return;
        
        multiSelected.forEach(obj => {
            objects = objects.filter(o => o !== obj);
            groups.forEach(group => {
                group.objects = group.objects.filter(o => o !== obj);
            });
        });
        
        groups = groups.filter(g => g.objects.length > 0);
        multiSelected = [];
        updateSidebar();
        draw();
    }
}
  
        function setupTextureEntryEvents(entry, textureName) {
    entry.className = "texture-entry";
    entry.style.display = "flex";
    entry.style.alignItems = "center";
    entry.style.justifyContent = "space-between";
    
    const nameSpan = document.createElement("span");
    nameSpan.textContent = textureName;
    nameSpan.style.flexGrow = "1";
    nameSpan.style.cursor = "pointer";
    
    // Сначала добавляем nameSpan в entry
    entry.appendChild(nameSpan);
    
    const img = imageCache[textureName];
    if (img) {
        const preview = document.createElement('img');
        preview.src = img.src;
        preview.style.width = '32px';
        preview.style.height = '32px';
        preview.style.marginRight = '5px';
        preview.style.objectFit = 'contain';
        
        // Вставляем превью перед nameSpan
        entry.insertBefore(preview, nameSpan);
    }
    
    const renameBtn = document.createElement("button");
    renameBtn.textContent = "✏️";
    renameBtn.title = "Переименовать текстуру";
    renameBtn.style.marginLeft = "5px";
    renameBtn.style.background = "none";
    renameBtn.style.border = "none";
    renameBtn.style.cursor = "pointer";
    renameBtn.onclick = (e) => {
        e.stopPropagation();
        showRenameTextureDialog(textureName);
    };
    
    const deleteBtn = document.createElement("button");
    deleteBtn.textContent = "🗑";
    deleteBtn.title = "Удалить текстуру";
    deleteBtn.style.marginLeft = "5px";
    deleteBtn.style.background = "none";
    deleteBtn.style.border = "none";
    deleteBtn.style.cursor = "pointer";
    deleteBtn.onclick = async (e) => {
        e.stopPropagation();
        const shouldDelete = await showModal({
            title: 'Удаление текстуры',
            message: `Удалить текстуру "${textureName}"? Это также удалит все связанные объекты.`,
            showCancel: true,
            confirmText: 'Удалить',
            cancelText: 'Отмена'
        });
        
        if (shouldDelete) {
            delete imageCache[textureName];
            objects = objects.filter(obj => obj.src !== textureName);
            groups.forEach(group => {
                group.objects = group.objects.filter(obj => obj.src !== textureName);
            });
            groups = groups.filter(g => g.objects.length > 0);
            
            if (selected && selected.src === textureName) {
                selected = null;
            }
            multiSelected = multiSelected.filter(obj => obj.src !== textureName);
            
            updateSidebar();
            draw();
        }
    };
    
    entry.appendChild(renameBtn);
    entry.appendChild(deleteBtn);
    
    entry.draggable = true;
    entry.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', JSON.stringify({
            src: textureName,
            name: textureName
        }));
    });
}
     
        function updateSidebar() {
    // Полностью очищаем fileList
    fileList.innerHTML = '';

    // Секция текстур
    const texturesHeader = document.createElement("h4");
    texturesHeader.textContent = "Текстуры";
    texturesHeader.id = "textures-header";
    texturesHeader.style.margin = "10px 0 5px 0";
    texturesHeader.style.color = "var(--text-main)";
    texturesHeader.style.fontSize = "14px";
    fileList.appendChild(texturesHeader);

    // Добавляем текстуры из imageCache
    Object.keys(imageCache).forEach(textureName => {
        const entry = document.createElement("div");
        setupTextureEntryEvents(entry, textureName);
        fileList.appendChild(entry);
    });
            
            // Секция групп
            if (groups.length > 0) {
                const groupsHeader = document.createElement("h4");
                groupsHeader.textContent = "Группы";
                groupsHeader.style.margin = "15px 0 5px 0";
                groupsHeader.style.color = "#555";
                groupsHeader.style.fontSize = "14px";
                fileList.appendChild(groupsHeader);

                groups.forEach(group => {
                    const groupContainer = document.createElement("div");
                    groupContainer.className = "group-container";
                    
                    // Group header
                    const groupHeader = document.createElement("div");
                    groupHeader.className = "group-header";

                    // Добавляем кнопки видимости и блокировки для всей группы
                    const groupEye = document.createElement("button");
                    groupEye.textContent = group.objects.every(obj => obj.visible) ? "👁" : "🚫";
                    groupEye.style.marginRight = "5px";
                    groupEye.onclick = (e) => {
                        e.stopPropagation();
                        const allVisible = group.objects.every(obj => obj.visible);
                        group.objects.forEach(obj => {
                        obj.visible = !allVisible;
                 });
                 draw();
              };

                   const groupLock = document.createElement("button");
                   groupLock.textContent = group.objects.every(obj => obj.locked) ? "🔒" : "🔓";
                   groupLock.style.marginRight = "5px";
                   groupLock.onclick = (e) => {
                       e.stopPropagation();
                       const allLocked = group.objects.every(obj => obj.locked);
                       group.objects.forEach(obj => {
                           obj.locked = !allLocked;
                   });
              };
                    
                    const groupName = document.createElement("input");
                    groupName.type = "text";
                    groupName.value = group.name;
                    groupName.className = "group-name";
                    groupName.style.flexGrow = "1";
                    groupName.style.marginRight = "5px";
                    groupName.style.border = "1px solid var(--border-color)";
                    groupName.style.padding = "2px";
                    groupName.addEventListener("change", () => {
                        group.name = groupName.value;
                    });
                     
                    // Создаем тулбар группы
const groupToolbar = document.createElement("div");
groupToolbar.className = "group-toolbar";
groupToolbar.style.background = "var(--selection-color)";

// Кнопка добавления в группу
const addToGroupBtn = document.createElement("button");
addToGroupBtn.className = "add-to-group-btn";
addToGroupBtn.textContent = "➕";
addToGroupBtn.title = "Добавить объекты в группу";
addToGroupBtn.onclick = (e) => {
    e.stopPropagation();
    // Сохраняем текущую группу как контекст
    const currentGroup = group;
    showAddToGroupModal(currentGroup);
};

                   const mergeBtn = document.createElement("button");
mergeBtn.className = "merge-btn";
mergeBtn.textContent = group.merged ? "🧷" : "🔗";
mergeBtn.title = group.merged ? "Разъединить объекты" : "Объединить объекты";
mergeBtn.className = "merge-btn";
mergeBtn.onclick = (e) => {
    e.stopPropagation();
    if (group.merged) {
        unmergeGroup(group);
    } else {
        mergeGroupObjects(group);
    }
};

                    
                    const toggleBtn = document.createElement("button");
                    toggleBtn.className = "toggle-btn";
                    toggleBtn.textContent = group.expanded ? "▼" : "▶";
                    toggleBtn.style.marginRight = "5px";
                    toggleBtn.style.background = "none";
                    toggleBtn.style.border = "none";
                    toggleBtn.style.cursor = "pointer";
                    toggleBtn.onclick = () => {
                        group.expanded = !group.expanded;
                        updateSidebar();
                    };
                    
                    const deleteBtn = document.createElement("button");
                    deleteBtn.className = "delete-btn";
                    deleteBtn.textContent = "🗑";
                    deleteBtn.style.background = "none";
                    deleteBtn.style.border = "none";
                    deleteBtn.style.cursor = "pointer";
                    deleteBtn.onclick = async (e) => {
                        if (await showModal({
    title: 'Удаление группы',
    message: `Удалить группу "${group.name}"?`,
    showCancel: true,
    confirmText: 'Удалить',
    cancelText: 'Отмена'
})) {
    groups = groups.filter(g => g.id !== group.id);
    updateSidebar();
  }
};
         
                    // Установка размеров кнопок (добавляется ПЕРЕД созданием структуры)
[groupEye, groupLock, addToGroupBtn, mergeBtn, toggleBtn, deleteBtn].forEach(btn => {
    btn.style.width = "24px";
    btn.style.height = "24px";
    btn.style.display = "flex";
    btn.style.justifyContent = "center";
    btn.style.alignItems = "center";
    btn.style.padding = "0";
});

// Создаем структуру группы (ЗАМЕНЯЕТ текущий код добавления элементов)
const leftControls = document.createElement("div");
leftControls.style.display = "flex";
leftControls.style.flexDirection = "column";
leftControls.style.gap = "5px";

// Верхний ряд - глаз и замок
const topRow = document.createElement("div");
topRow.style.display = "flex";
topRow.style.gap = "5px";
topRow.appendChild(groupEye);
topRow.appendChild(groupLock);
leftControls.appendChild(topRow);

// Нижний ряд - плюс и линк
const bottomRow = document.createElement("div");
bottomRow.style.display = "flex";
bottomRow.style.gap = "5px";
bottomRow.appendChild(addToGroupBtn);
bottomRow.appendChild(mergeBtn);
leftControls.appendChild(bottomRow);

// Добавляем левые контролы в header
groupHeader.appendChild(leftControls);

// Затем имя группы
groupHeader.appendChild(groupName);

// Правые кнопки (свернуть и удалить)
const rightControls = document.createElement("div");
rightControls.style.display = "flex";
rightControls.style.gap = "5px";
rightControls.appendChild(toggleBtn);
rightControls.appendChild(deleteBtn);
groupHeader.appendChild(rightControls);
                    


                    groupContainer.appendChild(groupHeader);
                    
                    // Group content
                    if (group.expanded) {
                        group.objects.forEach(obj => {
                            const objEntry = document.createElement("div");
                            objEntry.className = "object-entry" + (obj === selected ? " selected" : "");
                            objEntry.style.border = "1px solid var(--border-color)";
                            objEntry.style.background = "var(--bg-sidebar)";
                            objEntry.style.margin = "2px 0";
                            objEntry.style.padding = "4px";
                            objEntry.style.borderRadius = "3px";
                            objEntry.style.display = "flex";
                            objEntry.style.alignItems = "center";
                            
                            const eye = document.createElement("button");
                            eye.textContent = obj.visible ? "👁" : "🚫";
                            eye.style.marginRight = "5px";
                            eye.onclick = (e) => { 
                                e.stopPropagation();
                                obj.visible = !obj.visible; 
                                draw(); 
                            };
                            
                            const lock = document.createElement("button");
                            lock.textContent = obj.locked ? "🔒" : "🔓";
                            lock.style.marginRight = "5px";
                            lock.onclick = (e) => { 
                                e.stopPropagation();
                                obj.locked = !obj.locked; 
                            };
                            
                            const name = document.createElement("span");
                            name.className = "name";
                            name.textContent = obj.name || "Объект";
                            name.style.cursor = "pointer";
                            name.style.flexGrow = "1";
                            name.onclick = () => { 
                                selected = obj; 
                                multiSelected = multiSelected.filter(o => o !== obj);
                                draw(); 
                            };
                            
                            const deleteObjBtn = document.createElement("button");
                            deleteObjBtn.textContent = "🗑";
                            deleteObjBtn.style.marginLeft = "5px";
                            deleteObjBtn.style.background = "none";
                            deleteObjBtn.style.border = "none";
                            deleteObjBtn.style.cursor = "pointer";
                            deleteObjBtn.onclick = async (e) => {
                                e.stopPropagation();
                                if (await showModal({
    title: 'Удаление объекта',
    message: 'Удалить этот объект из группы?',
    showCancel: true,
    confirmText: 'Удалить',
    cancelText: 'Отмена'
})) {

                                    const objIndex = group.objects.indexOf(obj);
                                    if (objIndex !== -1) {
                                        group.objects.splice(objIndex, 1);
                                    }
                                    
                                    const globalObjIndex = objects.indexOf(obj);
                                    if (globalObjIndex !== -1) {
                                        objects.splice(globalObjIndex, 1);
                                    }
                                    
                                    if (selected === obj) selected = null;
                                    multiSelected = multiSelected.filter(o => o !== obj);
                                    
                                    // Remove empty groups
                                    groups = groups.filter(g => g.objects.length > 0);
                                    
                                    updateSidebar();
                                    draw();
                                }
                            };
                            
                            objEntry.appendChild(eye);
                            objEntry.appendChild(lock);
                            objEntry.appendChild(name);
                            objEntry.appendChild(deleteObjBtn);
                            groupContainer.appendChild(objEntry);
                        });
                    }
                    
                    fileList.appendChild(groupContainer);
                });
            }
            
            // Секция объектов
            if (objects.length > 0) {
                const objectsHeader = document.createElement("h4");
                objectsHeader.textContent = "Объекты на сцене";
                objectsHeader.style.margin = "15px 0 5px 0";
                objectsHeader.style.color = "#555";
                objectsHeader.style.fontSize = "14px";
                fileList.appendChild(objectsHeader);

                // Группируем объекты по src
                const groupedObjects = {};
                objects.forEach(obj => {
                    // Skip objects that are in groups
                    const isInGroup = groups.some(group => group.objects.includes(obj));
                    if (isInGroup) return;
                    
                    if (!obj.isCopy) {
                        if (!groupedObjects[obj.src]) {
                            groupedObjects[obj.src] = {
                                main: obj,
                                copies: []
                            };
                        }
                    } else {
                        const originalSrc = obj.src;
                        if (groupedObjects[originalSrc]) {
                            groupedObjects[originalSrc].copies.push(obj);
                        }
                    }
                });

                // Отображаем группы объектов
                Object.values(groupedObjects).forEach(group => {
                    const groupContainer = document.createElement("div");
                    groupContainer.style.marginBottom = "10px";
                    
                    // Основной объект
                    const mainEntry = document.createElement("div");
                    mainEntry.className = "object-entry" + (group.main === selected ? " selected" : "");
                    mainEntry.style.border = "1px solid var(--border-color)";
                    mainEntry.style.background = "var(--bg-sidebar)";
                    mainEntry.style.margin = "2px 0";
                    mainEntry.style.padding = "4px";
                    mainEntry.style.borderRadius = "3px";
                    mainEntry.style.display = "flex";
                    mainEntry.style.alignItems = "center";
                    
                    const eye = document.createElement("button");
                    eye.textContent = group.main.visible ? "👁" : "🚫";
                    eye.style.marginRight = "5px";
                    eye.onclick = (e) => { 
                        e.stopPropagation();
                        group.main.visible = !group.main.visible; 
                        draw(); 
                    };
                    
                    const lock = document.createElement("button");
                    lock.textContent = group.main.locked ? "🔒" : "🔓";
                    lock.style.marginRight = "5px";
                    lock.onclick = (e) => { 
                        e.stopPropagation();
                        group.main.locked = !group.main.locked; 
                    };
                    
                    const name = document.createElement("span");
                    name.className = "name";
                    name.textContent = group.main.name || "Объект";
                    name.style.cursor = "pointer";
                    name.style.flexGrow = "1";
                    name.onclick = () => { 
                        if (ctrlHeld) {
                            if (multiSelected.includes(group.main)) {
                                multiSelected = multiSelected.filter(o => o !== group.main);
                            } else {
                                multiSelected.push(group.main);
                            }
                        } else {
                            selected = group.main; 
                            multiSelected = [];
                        }
                        draw(); 
                    };
                    
                    const deleteBtn = document.createElement("button");
deleteBtn.className = "delete-btn";
deleteBtn.textContent = "🗑";
deleteBtn.title = "Удалить текстуру";
deleteBtn.style.marginLeft = "5px";
deleteBtn.style.background = "none";
deleteBtn.style.border = "none";
deleteBtn.style.cursor = "pointer";
deleteBtn.onclick = async (e) => {
    e.stopPropagation();
    const shouldDelete = await showModal({
        title: 'Удаление объекта',
        message: `Удалить этот объект и все его копии (${findCopiesOf(group.main).length})?`,
        showCancel: true,
        confirmText: 'Удалить',
        cancelText: 'Отмена'
    });
    
    if (shouldDelete) {
        const currentSrc = group.main.src;
        delete expandedStates[currentSrc]; // Удаляем состояние для этого src
        
        const copies = findCopiesOf(group.main);
        
        // Удаляем оригинал и копии
        objects = objects.filter(obj => 
            obj !== group.main && 
            !copies.includes(obj)
        );
        
        // Удаляем из групп
        groups.forEach(group => {
            group.objects = group.objects.filter(obj => 
                obj !== group.main && 
                !copies.includes(obj)
            );
        });
        
        // Удаляем пустые группы
        groups = groups.filter(g => g.objects.length > 0);
        
        if (selected && (selected.src === currentSrc || copies.includes(selected))) {
            selected = null;
        }
        multiSelected = multiSelected.filter(o => 
            o !== group.main && 
            !copies.includes(o)
        );
        
        updateSidebar();
        draw();
    }
};

const currentSrc = group.main.src;
const wasExpanded = expandedStates[currentSrc] || false;
                    
                    // Кнопка раскрытия копий
if (group.copies.length > 0) {
    const toggleBtn = document.createElement("button");
    toggleBtn.className = "toggle-btn";
    toggleBtn.textContent = expandedStates[currentSrc] ? "▼" : "▶";
    toggleBtn.style.marginLeft = "5px";
    toggleBtn.style.background = "none";
    toggleBtn.style.border = "none";
    toggleBtn.style.cursor = "pointer";
    toggleBtn.onclick = (e) => {
        e.stopPropagation();
        expandedStates[currentSrc] = !expandedStates[currentSrc];
        updateSidebar();
    };
    mainEntry.appendChild(toggleBtn);
}
                    
                    
                    mainEntry.appendChild(eye);
                    mainEntry.appendChild(lock);
                    mainEntry.appendChild(name);
                    mainEntry.appendChild(deleteBtn);
                    groupContainer.appendChild(mainEntry);
                    
                    // Контейнер для копий
                    const copiesContainer = document.createElement("div");
                    copiesContainer.className = "copies-container";
                    copiesContainer.setAttribute("data-src", currentSrc);
                    copiesContainer.style.display = wasExpanded ? "block" : "none";
                    copiesContainer.style.marginLeft = "15px";
                    
                    
                    group.copies.forEach((copy, index) => {
                        const copyEntry = document.createElement("div");
                        copyEntry.className = "object-entry" + (copy === selected ? " selected" : "");
                        copyEntry.style.border = "1px solid var(--border-color)";
                        copyEntry.style.background = "var(--bg-canvas)";
                        copyEntry.style.margin = "2px 0";
                        copyEntry.style.padding = "4px";
                        copyEntry.style.borderRadius = "3px";
                        copyEntry.style.display = "flex";
                        copyEntry.style.alignItems = "center";
                        
                        const copyEye = document.createElement("button");
                        copyEye.textContent = copy.visible ? "👁" : "🚫";
                        copyEye.style.marginRight = "5px";
                        copyEye.onclick = (e) => { 
                            e.stopPropagation();
                            copy.visible = !copy.visible; 
                            draw(); 
                        };
                        
                        const copyLock = document.createElement("button");
                        copyLock.textContent = copy.locked ? "🔒" : "🔓";
                        copyLock.style.marginRight = "5px";
                        copyLock.onclick = (e) => { 
                            e.stopPropagation();
                            copy.locked = !copy.locked; 
                        };
                        
                        const copyName = document.createElement("span");
                        copyName.className = "name";
                        copyName.textContent = `Копия ${index + 1}`;
                        copyName.style.cursor = "pointer";
                        copyName.style.flexGrow = "1";
                        copyName.onclick = () => { 
                            if (ctrlHeld) {
                                if (multiSelected.includes(copy)) {
                                    multiSelected = multiSelected.filter(o => o !== copy);
                                } else {
                                    multiSelected.push(copy);
                                }
                            } else {
                                selected = copy; 
                                multiSelected = [];
                            }
                            draw(); 
                        };
                        
                        const deleteCopyBtn = document.createElement("button");
deleteCopyBtn.textContent = "🗑";
deleteCopyBtn.style.marginLeft = "5px";
deleteCopyBtn.style.background = "none";
deleteCopyBtn.style.border = "none";
deleteCopyBtn.style.cursor = "pointer";
deleteCopyBtn.onclick = async (e) => {
    e.stopPropagation();
    const shouldDelete = await showModal({
        title: 'Удаление копии',
        message: 'Удалить эту копию?',
        showCancel: true,
        confirmText: 'Удалить',
        cancelText: 'Отмена'
    });
    
    if (shouldDelete) {
        const currentSrc = group.main.src;
        const wasExpanded = expandedStates[currentSrc] || false;
        
        // Удаляем копию
        const index = objects.indexOf(copy);
        if (index !== -1) objects.splice(index, 1);
        
        // Удаляем из групп
        groups.forEach(group => {
            const objIndex = group.objects.indexOf(copy);
            if (objIndex !== -1) group.objects.splice(objIndex, 1);
        });
        
        // Удаляем пустые группы
        groups = groups.filter(g => g.objects.length > 0);
        
        if (selected === copy) selected = null;
        multiSelected = multiSelected.filter(o => o !== copy);
        
        // Получаем оставшиеся копии этого объекта
        const remainingCopies = findCopiesOf(group.main);
        
        // Если это была последняя копия, удаляем состояние раскрытия
        if (remainingCopies.length === 0) {
            delete expandedStates[currentSrc];
        }
        
        updateSidebar();
        
        // Восстанавливаем состояние раскрытия только если есть другие копии
        if (remainingCopies.length > 0) {
            const newContainer = document.querySelector(`.copies-container[data-src="${currentSrc}"]`);
            if (newContainer) {
                newContainer.style.display = wasExpanded ? "block" : "none";
                const toggleBtn = newContainer.parentElement.querySelector("button");
                if (toggleBtn) {
                    toggleBtn.textContent = wasExpanded ? "▼" : "▶";
                }
            }
        }
        
        draw();
    }
};
                        
                        copyEntry.appendChild(copyEye);
                        copyEntry.appendChild(copyLock);
                        copyEntry.appendChild(copyName);
                        copyEntry.appendChild(deleteCopyBtn);
                        copiesContainer.appendChild(copyEntry);
                    });
                    
                    groupContainer.appendChild(copiesContainer);
                    fileList.appendChild(groupContainer);
                });
            }
        }

        // Обработка файлов
        fileInput.addEventListener("change", async function(e) {
    if (isProcessingFiles) return;
    isProcessingFiles = true;
    
    const files = Array.from(e.target.files);
    if (files.length === 0) {
        isProcessingFiles = false;
        return;
    }

    showLoadingIndicator();

    try {
        for (const file of files) {
            // Пропускаем файлы с уже существующими именами
            if (imageCache[file.name]) {
                console.log(`Пропущен дубликат: ${file.name}`);
                continue;
            }
            
            await new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        imageCache[file.name] = img;
                        resolve();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        updateSidebar();
        draw();
    } catch (error) {
        console.error("Ошибка загрузки:", error);
        showAlert("Ошибка загрузки файлов");
    } finally {
        isProcessingFiles = false;
        e.target.value = '';
        hideLoadingIndicator();
    }
});        
        // Разворачиваем WebApp (макс. 3 попытки)
        if (window.Telegram && Telegram.WebApp && !Telegram.WebApp.isExpanded) {
            let attempts = 0;
            const tryExpand = () => {
                attempts++;
                Telegram.WebApp.expand();
                if (attempts < 3 && !Telegram.WebApp.isExpanded) {
                    setTimeout(tryExpand, 300);
                }
            };
            tryExpand();
        }

        // Обработка перетаскивания на canvas
        canvas.addEventListener("dragover", function(e) {
            e.preventDefault();
        });

        canvas.addEventListener("drop", function(e) {
    e.preventDefault();
    const data = JSON.parse(e.dataTransfer.getData("text/plain"));
    const img = imageCache[data.src];
    
    if (img) {
        const rect = canvas.getBoundingClientRect();
        const ratio = window.devicePixelRatio || 1;
        
        // Правильное преобразование координат с учётом zoom и камеры
        const rawX = (e.clientX - rect.left) * ratio;
        const rawY = (e.clientY - rect.top) * ratio;
        
        // Переводим в мировые координаты (учитывая zoom и камеру)
        const worldX = rawX / zoom + cameraX;
        const worldY = rawY / zoom + cameraY;
        
        // Привязываем к сетке
        const x = Math.floor(worldX / gridSize) * gridSize;
        const y = Math.floor(worldY / gridSize) * gridSize;
        
        // Проверяем, есть ли уже такой объект на сцене
        const existingObject = objects.find(obj => 
            obj.src === data.src && 
            Math.abs(obj.x - x) < gridSize && 
            Math.abs(obj.y - y) < gridSize
        );
        
        if (existingObject) {
            selected = existingObject;
            draw();
            return;
        }
        
        const newObj = {
            name: data.name,
            src: data.src,
            x: x,
            y: y,
            w: gridSize,
            h: gridSize,
            visible: true,
            locked: false,
            isCopy: objects.some(obj => obj.src === data.src)
        };
        
        objects.push(newObj);
        updateSidebar();
        draw();
    }
});

        // Обработчики событий canvas
        canvas.addEventListener("mousedown", function(e) {
            const mx = e.offsetX / zoom + cameraX;
            const my = e.offsetY / zoom + cameraY;
            
            // 1. Сначала проверяем клик по объединенной группе
            for (const group of groups) {
                if (group.merged && group.mergedObject && group.mergedObject.visible) {
                    if (mx >= group.mergedObject.x && mx <= group.mergedObject.x + group.mergedObject.w &&
                        my >= group.mergedObject.y && my <= group.mergedObject.y + group.mergedObject.h) {
                        
                        // Проверяем, кликнули ли мы в области ресайза (правый нижний угол)
                        const resizeHandleSize = 16;
                        const isResizing = 
                            mx >= group.mergedObject.x + group.mergedObject.w - resizeHandleSize && 
                            my >= group.mergedObject.y + group.mergedObject.h - resizeHandleSize;
                        
                        selected = null;
                        multiSelected = [];
                        resizing = isResizing;
                        dragging = !isResizing;
                        
                        currentMergedGroup = group;
                        offsetX = mx - group.mergedObject.x;
                        offsetY = my - group.mergedObject.y;
                        
                        draw();
                        return;
                    }
                }
            }

            if (e.button === 0) {
                let clickedOnObject = false;
                
                // Проверка на ресайз (перебираем в обратном порядке)
                for (let i = objects.length - 1; i >= 0; i--) {
                    const obj = objects[i];
                    if (!obj.visible || obj.locked) continue;
                    
                    const x = (obj.x - cameraX) * zoom;
                    const y = (obj.y - cameraY) * zoom;
                    const w = obj.w * zoom;
                    const h = obj.h * zoom;
                    
                    const resizeArea = 16;
                    if (e.offsetX >= x + w - resizeArea && e.offsetX <= x + w + resizeArea &&
                        e.offsetY >= y + h - resizeArea && e.offsetY <= y + h + resizeArea) {
                        selected = obj;
                        multiSelected = [];
                        resizing = true;
                        resizeAnchor = "br";
                        clickedOnObject = true;
                        offsetX = mx - obj.x;
                        offsetY = my - obj.y;
                        break;
                    }
                }

                // Проверка на перетаскивание (перебираем в обратном порядке)
                if (!clickedOnObject) {
                    for (let i = objects.length - 1; i >= 0; i--) {
                        const obj = objects[i];
                        if (!obj.visible || obj.locked) continue;
                        if (mx >= obj.x && mx <= obj.x + obj.w && 
                            my >= obj.y && my <= obj.y + obj.h) {
                            if (ctrlHeld) {
                                // Multi-select mode
                                if (multiSelected.includes(obj)) {
                                    multiSelected = multiSelected.filter(o => o !== obj);
                                } else {
                                    multiSelected.push(obj);
                                }
                                clickedOnObject = true;
                            } else {
                                // Single select mode
                                selected = obj;
                                multiSelected = [];
                                offsetX = mx - obj.x;
                                offsetY = my - obj.y;
                                dragging = true;
                                clickedOnObject = true;
                            }
                            break;
                        }
                    }
                }

                if (!clickedOnObject) {
                    if (e.altKey) {
                        // Если ничего не выделено и нажат Alt - двигаем камеру
                        dragScene = true;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                    } else if (!ctrlHeld) {
                        // Просто снимаем выделение, если не в режиме multi-select
                        selected = null;
                        multiSelected = [];
                    }
                }
                draw();
            }
        });

        canvas.addEventListener("mousemove", function(e) {
            const mx = e.offsetX / zoom + cameraX;
            const my = e.offsetY / zoom + cameraY;
            
            if (dragScene) {
                cameraX -= (e.clientX - dragStartX) / zoom;
                cameraY -= (e.clientY - dragStartY) / zoom;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                draw();
                return;
            }

            if (playerStartMode && tempPlayerStart) {
    tempPlayerStart.x = Math.floor(mx / gridSize) * gridSize;
    tempPlayerStart.y = Math.floor(my / gridSize) * gridSize;
    draw();
}
            
            // Обработка ресайза объединенной группы
if (resizing && currentMergedGroup?.merged) {
    const group = currentMergedGroup;
    const newWidth = Math.max(gridSize, mx - group.mergedObject.x);
    const newHeight = Math.max(gridSize, my - group.mergedObject.y);
    
    // Сохраняем новые размеры группы
    group.mergedObject.w = newWidth;
    group.mergedObject.h = newHeight;
    
    // Обновляем все объекты в группе пропорционально
    group.originalState.objects.forEach((original, index) => {
        const obj = group.objects[index];
        obj.x = group.mergedObject.x + original.relX * newWidth;
        obj.y = group.mergedObject.y + original.relY * newHeight;
        obj.w = original.relW * newWidth;
        obj.h = original.relH * newHeight;
    });
    
    draw();
    return;
}
            
            // Обработка ресайза обычного объекта
            if (resizing && selected) {
                const newWidth = Math.max(gridSize, mx - selected.x);
                const newHeight = Math.max(gridSize, my - selected.y);
                
                selected.w = newWidth;
                selected.h = newHeight;
                
                draw();
                return;
            }
            
            // Обработка перемещения объединенной группы
            if (dragging && currentMergedGroup?.merged) {
                const group = currentMergedGroup;
                let newX = mx - offsetX;
                let newY = my - offsetY;
                
                if (!e.altKey) {
                    newX = Math.round(newX / gridSize) * gridSize;
                    newY = Math.round(newY / gridSize) * gridSize;
                }
                
                // Вычисляем смещение
                const deltaX = newX - group.mergedObject.x;
                const deltaY = newY - group.mergedObject.y;
                
                // Обновляем позицию группы
                group.mergedObject.x = newX;
                group.mergedObject.y = newY;
                
                // Обновляем все объекты в группе
                group.objects.forEach(obj => {
                    obj.x += deltaX;
                    obj.y += deltaY;
                });
                
                draw();
                return;
            }
            
            // Обработка перемещения обычных объектов
            if (dragging && (selected || multiSelected.length > 0)) {
                let newX = mx - offsetX;
                let newY = my - offsetY;
                
                if (!e.altKey) {
                    newX = Math.round(newX / gridSize) * gridSize;
                    newY = Math.round(newY / gridSize) * gridSize;
                }
                
                if (selected) {
                    const deltaX = newX - selected.x;
                    const deltaY = newY - selected.y;
                    
                    selected.x = newX;
                    selected.y = newY;
                    
                    // Если есть мультивыделение, перемещаем и их тоже
                    if (multiSelected.length > 0) {
                        multiSelected.forEach(obj => {
                            obj.x += deltaX;
                            obj.y += deltaY;
                        });
                    }
                } else if (multiSelected.length > 0) {
                    const deltaX = newX - multiSelected[0].x;
                    const deltaY = newY - multiSelected[0].y;
                    
                    multiSelected.forEach(obj => {
                        obj.x += deltaX;
                        obj.y += deltaY;
                    });
                }
                
                draw();
            }
        });

        canvas.addEventListener("mouseup", function(e) {
    if (playerStartMode && tempPlayerStart && e.button === 0) {
                // Удаляем старую стартовую позицию, если она есть
                objects = objects.filter(obj => obj.type !== "playerStart");
                
                // Создаем новую стартовую позицию
                const newPlayerStart = {
                    x: tempPlayerStart.x,
                    y: tempPlayerStart.y,
                    w: tempPlayerStart.w,
                    h: tempPlayerStart.h,
                    type: "playerStart",
                    visible: true,
                    name: "Player Start"
                };
                
                objects.push(newPlayerStart);
                selected = newPlayerStart;
                multiSelected = [];
                
                // Выходим из режима установки
                setPlayerStartMode();
                
                updateSidebar();
                draw();
            }
            
            dragging = false;
            resizing = false;
            dragScene = false;
            currentMergedGroup = null;
        });

        // Обработка клавиатуры
        window.addEventListener("keydown", function(e) {
    if (playerStartMode && tempPlayerStart && e.key === "Enter") {
                // Удаляем старую стартовую позицию, если она есть
                objects = objects.filter(obj => obj.type !== "playerStart");
                
                // Создаем новую стартовую позицию
                const newPlayerStart = {
                    x: tempPlayerStart.x,
                    y: tempPlayerStart.y,
                    w: tempPlayerStart.w,
                    h: tempPlayerStart.h,
                    type: "playerStart",
                    visible: true,
                    name: "Player Start"
                };
                
                objects.push(newPlayerStart);
                selected = newPlayerStart;
                multiSelected = [];
                
                // Выходим из режима установки
                setPlayerStartMode();
                
                updateSidebar();
                draw();
                e.preventDefault();
            }

    if (e.ctrlKey && !e.altKey && !e.shiftKey && e.key === 'z') {
        const action = undoManager.undo();
        if (action) {
            action.undo();
            e.preventDefault();
        }
        return;
    }

    if (e.ctrlKey && e.key === 'y' && !e.altKey && !e.shiftKey) {
        const action = undoManager.redo();
        if (action) {
            action.redo();
            e.preventDefault();
        }
        return;
    }

    if (e.ctrlKey && e.shiftKey && e.key === 'Z') {
        const action = undoManager.redo();
        if (action) {
            action.redo();
            e.preventDefault();
        }
        return;
    }

    if (e.key === "Alt") altHeld = true;
    if (e.key === "Control") ctrlHeld = true;
    if (!keyState[e.key]) {
        keyState[e.key] = {
            pressed: true,
            timestamp: Date.now(),
            repeat: false
        };
    } else {
        keyState[e.key].repeat = true;
    }
    
    // Копирование объекта
    if (e.ctrlKey && e.key === "c" && selected) {
        copySelectedObject();
        e.preventDefault();
        return;
    }
    
    // Создание группы
    if (e.ctrlKey && e.key === "i") {
        createGroupFromSelection();
        e.preventDefault();
        return;
    }
    
    // Удаление объектов
    if (e.ctrlKey && e.key === "Delete") {
        deleteSelectedObjects();
        e.preventDefault();
        return;
    }

    // Обработка стрелок (только если есть выделение)
    if ((selected || multiSelected.length > 0) && !e.ctrlKey && !e.metaKey) {
        const now = Date.now();
        const timeSinceLastMove = now - lastMoveTime;
        
        // Определяем шаг перемещения
        let step;
        if (e.shiftKey) {
            step = moveSpeed.precise; // Точное перемещение по 1px
        } else if (keyState[e.key]?.repeat && timeSinceLastMove < 300) {
            step = moveSpeed.accelerated; // Ускорение после зажатия
        } else {
            step = moveSpeed.base; // Обычный шаг (размер сетки)
        }

        // Функция для перемещения с учетом сетки
        const moveObject = (obj, dx, dy) => {
            if (e.altKey) {
                // Свободное перемещение без привязки к сетке
                obj.x += dx;
                obj.y += dy;
            } else {
                // Привязка к сетке
                obj.x = Math.round((obj.x + dx) / gridSize) * gridSize;
                obj.y = Math.round((obj.y + dy) / gridSize) * gridSize;
            }
        };

        let moved = false;
        const moveStep = e.shiftKey ? moveSpeed.precise : step;
        
        switch(e.key) {
            case "ArrowUp":
            case "w":
                if (selected) moveObject(selected, 0, -moveStep);
                multiSelected.forEach(obj => moveObject(obj, 0, -moveStep));
                moved = true;
                break;
            case "ArrowDown":
            case "s":
                if (selected) moveObject(selected, 0, moveStep);
                multiSelected.forEach(obj => moveObject(obj, 0, moveStep));
                moved = true;
                break;
            case "ArrowLeft":
            case "a":
                if (selected) moveObject(selected, -moveStep, 0);
                multiSelected.forEach(obj => moveObject(obj, -moveStep, 0));
                moved = true;
                break;
            case "ArrowRight":
            case "d":
                if (selected) moveObject(selected, moveStep, 0);
                multiSelected.forEach(obj => moveObject(obj, moveStep, 0));
                moved = true;
                break;
        }

        if (moved) {
            lastMoveTime = now;
            e.preventDefault();
            draw();
            return;
        }
    }
    
    if (selected && !selected.locked) {
        if (e.key === "+" || e.key === "=") {
            selected.w += gridSize;
            selected.h += gridSize;
            draw();
        }
        if (e.key === "-" || e.key === "_") {
            selected.w = Math.max(gridSize, selected.w - gridSize);
            selected.h = Math.max(gridSize, selected.h - gridSize);
            draw();
        }
    }
});

        window.addEventListener("keyup", function(e) {  
    if (e.key === "Alt") altHeld = false;
    if (e.key === "Control") ctrlHeld = false;
});

        // Управляющие функции
        function zoomIn() {
    const newZoom = Math.min(1.0, Math.round((zoom + 0.1) * 10) / 10);
    if (newZoom !== zoom) {
        zoom = newZoom;
        draw();
        updateZoomDisplay();
    }
}

function zoomOut() {
    const newZoom = Math.max(0.1, Math.round((zoom - 0.1) * 10) / 10);
    if (newZoom !== zoom) {
        zoom = newZoom;
        draw();
        updateZoomDisplay();
    }
}

function resetZoom() {
    zoom = 1.0;
    draw();
    updateZoomDisplay();
}
            function saveMap() {
    const mapData = {
        style: gameStyle,
        objects: objects,
        gridSize: gridSize,
        meta: {
            created: new Date().toISOString(),
            editor: "Telegram Map Editor"
        }
    };
    
    const jsonData = JSON.stringify(mapData, null, 2);
    output.value = jsonData;
    return jsonData;
}

        async function clearScene() {
    ensureWebAppExpanded();
    
    const shouldClear = await showModal({
        title: 'Очистка сцены',
        message: 'Вы уверены, что хотите очистить сцену? Все объекты будут удалены.',
        showCancel: true,
        confirmText: 'Очистить',
        cancelText: 'Отмена'
    });
    
    if (shouldClear) {
        objects = [];
        selected = null;
        multiSelected = [];
        groups = [];
        gameStyle = 'topdown';
        gridSize = 64;
        updateSidebar();
        draw();
        updateZoomDisplay();
    }
}

        function loadMap(jsonData) {
    try {
        const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
        
        // Устанавливаем стиль карты
        if (data.style) {
            gameStyle = data.style;
            selectGameStyle(data.style); // Обновляем интерфейс
        }
        
        // Загружаем объекты
        if (Array.isArray(data.objects)) {
            objects = data.objects;
        } else if (Array.isArray(data)) { // Для обратной совместимости
            objects = data;
        }
        
        // Обновляем интерфейс
        updateSidebar();
        draw();
        
        return true;
    } catch (e) {
        console.error("Ошибка загрузки карты:", e);
        return false;
    }
}

        function exitEditor() {
            window.close();
        }

        // Обертываем основные функции для поддержки undo/redo
const functionsToWrap = [
    'copySelectedObject',
    'createGroupFromSelection',
    'deleteSelectedObjects',
    'zoomIn',
    'zoomOut',
    'togglePlay',
    'saveMap',
    'clearScene',
    'mergeGroupObjects',
    'unmergeGroup',
]; 

functionsToWrap.forEach(fnName => {
    const originalFn = window[fnName];
    if (originalFn) {
        window[fnName] = wrapWithUndo(originalFn);
    }
});

// Модифицируем обработчики событий для поддержки undo/redo
// Модифицируем обработчики событий для поддержки undo/redo
let lastMouseDownState;

const originalMouseDownHandler = canvas.onmousedown;
canvas.onmousedown = function(e) {
    lastMouseDownState = saveState();
    if (originalMouseDownHandler) {
        originalMouseDownHandler.call(this, e);
    }
};

const originalMouseUpHandler = canvas.onmouseup;
canvas.onmouseup = function(e) {
    if (originalMouseUpHandler) {
        originalMouseUpHandler.call(this, e);
    }
    
    // Добавляем действие в историю после отпускания кнопки мыши
    const currentState = saveState();
    if (lastMouseDownState && JSON.stringify(lastMouseDownState) !== JSON.stringify(currentState)) {
        undoManager.addAction({
            undo: () => restoreState(lastMouseDownState),
            redo: () => restoreState(currentState)
        });
    }
};

// Модифицируем функцию clearScene для очистки истории
const originalClearScene = window.clearScene;
window.clearScene = function() {
    const beforeState = saveState();
    originalClearScene();
    const afterState = saveState();
    
    undoManager.addAction({
        undo: () => restoreState(beforeState),
        redo: () => restoreState(afterState)
    });
};

        // Инициализация 1
        function init() {
            initTheme();
            resizeCanvas();
            draw();
            updateZoomDisplay();
            updateSidebar();
            setupSaveButton();

        // Инициализация данных
    window.currentMapData = getMapData();
    window.currentObjects = objects.reduce((acc, obj, idx) => {
        acc[`obj_${idx}`] = obj;
        return acc;
    }, {});


        const sidebar = document.getElementById('sidebar');
const resizeHandle = document.querySelector('.sidebar-resize-handle');
let isResizing = false;

resizeHandle.addEventListener('mousedown', function(e) {
    ensureWebAppExpanded();
    isResizing = true;
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';
    e.preventDefault();
});

document.addEventListener('mousemove', function(e) {
    if (!isResizing) return;
    
    const newWidth = window.innerWidth - e.clientX;
    
    if (newWidth > 260 && newWidth < 600) {
        sidebar.style.width = newWidth + 'px';
        
        // Обновляем позицию элементов управления
        const themeToggle = document.querySelector('.theme-toggle');
        const controls = document.getElementById('controls');
        const sidebarWidth = parseInt(sidebar.style.width);
        
        themeToggle.style.left = (sidebarWidth + 20) + 'px';
        controls.style.left = (sidebarWidth + 20) + 'px';
        
        resizeCanvas();
    }
    e.preventDefault();
});

document.addEventListener('mouseup', function() {
    if (isResizing) {
        isResizing = false;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
    }
});
}
        fileList.addEventListener('click', function(e) {
    if (e.target.tagName === 'BUTTON' && e.target.title === "Переименовать текстуру") {
        const textSpan = e.target.parentNode.querySelector('span');
        if (!textSpan) return;
        
        const textureName = textSpan.textContent;
        if (textureName && imageCache[textureName]) {
        }
    }
});
     
        // Инициализация 2
        window.addEventListener('DOMContentLoaded', function() {
        // Инициализация Telegram WebApp
        if (window.Telegram && Telegram.WebApp) {
            // 1. Разворачиваем на весь экран
            Telegram.WebApp.expand();
            
            // 2. Применяем тему Telegram
            applyTelegramTheme();
               
            // 4. Слушаем изменения темы
            Telegram.WebApp.onEvent('themeChanged', applyTelegramTheme);

            // 5. Автоматическое разворачивание при сворачивании
            Telegram.WebApp.onEvent('viewportChanged', (event) => {
                if (!event.is_expanded) {
                    setTimeout(() => Telegram.WebApp.expand(), 100);
                }
            });

            // 6. Периодическая проверка (на случай редких сбоев)
            setInterval(() => {
                if (!Telegram.WebApp.isExpanded) {
                    Telegram.WebApp.expand();
                }
            }, 5000); // Проверка каждые 5 сек
            
            // 7. Получаем начальные данные проекта (новый код)
            if (Telegram.WebApp.initDataUnsafe.start_param) {
                loadInitialData(Telegram.WebApp.initDataUnsafe.start_param);
            }
        }
        

        // Показываем модальное окно выбора стиля
        document.getElementById('styleModal').style.display = 'flex';
        
        // Обработчики для кнопок выбора стиля
        document.querySelectorAll('.style-option').forEach(option => {
            option.addEventListener('click', function() {
                selectGameStyle(this.getAttribute('data-style'));
                init();
            });
        });
    });

          // Добавляем новую функцию для загрузки начальных данных
          async function loadInitialData(projectName) {
  try {
    const user_id = Telegram.WebApp.initDataUnsafe?.user?.id;
    
    const response = await fetch(
      `http://localhost:3000/get_project_data?project=${projectName}&user_id=${user_id}`
    );
    
    const data = await response.json();
    
    if (data.map) {
      loadMap(data.map);
      
      // Загрузка текстур
      if (data.textures) {
        await Promise.all(
          data.textures.map(texture => 
            loadTexture(texture.name, texture.url)
          )
        );
      }
    }
  } catch (error) {
    console.error('Loading error:', error);
  }
}

async function loadTexture(name, url) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      imageCache[name] = img;
      resolve();
    };
    img.src = url;
  });
}

        // Инициализация кнопки при загрузке
       document.addEventListener('DOMContentLoaded', () => {
       initExportLibraries();
       setupSaveButton();
    });
        window.addEventListener("resize", resizeCanvas);
    </script>
</body>
</html>